Java 虚拟机--Java 内存区域
====================
## 1 运行时数据区域
<div align="center"> <img src="images/040101.jpg" width="520px"> </div><br>

### 1.1 程序计数器
是一块较小的内存空间，一个特殊用途的寄存器，可以看作是当前线程所执行字节码的行号指示器。在虚拟机概念模型中，字节码解释器工作时就是**通过改变计数器的值来选取下一条需要执行的字节码指令**，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。

### 1.2 Java 虚拟机栈
每个 Java 方法在执行的同时会创建一个栈帧用于存储**局部变量表**、**操作数栈**、**常量池引用**等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

可以通过虚拟机参数 `-Xss` 来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.5+ 默认为 1M
```java
java -Xss2M HackTheJava
```

该区域可能抛出以下异常：
- 当线程请求的栈深度超过最大值，会抛出 `StackOverflowError` 异常；
- 栈进行动态扩展时如果无法申请到足够内存，会抛出 `OutOfMemoryError` 异常。

### 1.3 本地方法栈
本地方法栈与 Java 虚拟机栈作用很相似，它们的区别在于虚拟机栈为虚拟机执行 Java 方法（即字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。

### 1.4 堆
对于大多数应用而言，Java 堆（Heap）是 Java 虚拟机所管理内存中最大的一块，它被所有线程共享的，在虚拟机启动时创建。此内存区域唯一的目的是存放对象实例，几乎所有的对象实例都在这里分配内存，且每次分配的空间是不定长的。

Java 堆是垃圾收集器管理的主要区域，因此也被称为“GC堆（Garbage Collected Heap）”。从内存回收的角度看内存空间划分如下图。

<img src=".\images\040104.png" alt="040104" style="zoom: 80%;" />

- **新生代（Young）**： 新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集一般可以回收 70% ~ 95% 的空间，回收效率很高。
- **老年代（Tenured/Old）**：在新生代中经历了多次（阀值）GC 后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行 GC 的频率相对而言较低，而且回收的速度也比较慢。

- 从图中可以看出： **堆大小 = 新生代 + 老年代**。堆的大小可以通过参数  `-Xms(初始值)` 和 `-Xmx(最大值)` 来指定。
- 默认的，**新生代：老年代 = 1:2** ( 可通过参数 `–XX:NewRatio` 来指定 )。
- 新生代被细分为  Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to 以示区分。
  默认的，**Eden : Survivor from : Survivor to = 8 : 1 : 1** ( 可通过参数 `–XX:SurvivorRatio` 来设定 )。
- JVM 每次只使用 Eden 和其中一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。也就是说，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。

### 1.5 方法区
方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域。**Object Class Data(类定义数据)、常量、静态变量、JIT 编译后的代码**存储在方法区。方法区是逻辑层面的概念。

对这块区域进行垃圾回收的主要目标是对**常量池的回收和对类的卸载**，但是一般比较难实现。HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.7 之后，字符串常量池从永久代中剥离出来，存放在堆中。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储虚拟机加载的类信息，静态变量，常量等数据。

### 1.6 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中的常量（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。

### 1.7 直接内存
直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但这部分内存也被频繁运用，而却可能导致 OutOfMemoryError 异常出现。

以 NIO（New Input/Output）类为例，NIO 引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能避免在 Java 堆和 Native 堆中来回复制数据，在一些场景里可以显著提高性能。

## 2 HotSpot 中的对象

### 2.1 对象的创建

**创建 Java 对象的四种方式**：

- **new 关键字** : 我们最常见和最常用最简单的创建对象的方式。

- **使用 newInstance() 方法** : 这里包括 Class 类的 newInstance() 方法和 Constructor 类的 newInstance() 方法。

- **使用 clone() 方法** ： 要使用 clone() 方法必须实现 Cloneable 接口。用 clone() 方法创建对象并不会调用任何构造函数（浅拷贝）。
  
- **反序列化** : 要实现反序列化需要让我们的类实现 Serializable 接口。当序列化和反序列化一个对象时，JVM 会创建一个单独的对象。在反序列化时，JVM 创建对象也不会调用任何构造函数。(深拷贝)

**虚拟机遇到一条 new 指令时会做如下5个动作：**

- **1).类加载检查**  

  虚拟机遇到一条 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已进行类加载，如果没有，则先执行相应的类加载过程。

- **2).分配内存**  

  在类加载检查通过后，虚拟机就将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间就是从 Java 堆中划出一块大小确定的内存空间。

  **分配内存的方式**有两种：

  - **指针碰撞（Bump The Pointer）** ：当 Java 堆中**内存绝对规整**时，所有用过的内存都被放在一边，空闲的内存被放在另一边，中间放一个指针作为分界点的指示器，分配内存就是把指针向空间内存那边挪动一段与对象大小相等的距离。 
  - **空闲列表（Free List）** ：当 Java 堆中的**内存不规整**时， 已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配内存的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

  _选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有**压缩整理功能**决定。_

- **3).初始化** 

  内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。保证了实例字段在 Java 代码中可以不赋初始值而直接使用。

- **4).对对象进行必要的设置**  

  虚拟机要设置对象的信息，如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息，这些信息存放在对象的对象头（Object Header）中。

- **5).执行 \<init> 方法**  

  在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在 Java 程序的视角看来，对象创建才刚刚开始——\<init> 方法还没有执行，所有的字段都还为零值。所以一般来说（由字节码中是否跟随有 invokespecial 指令所决定），new 指令之后会接着执行 \<init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

并发情况下，Java 程序存在线程安全的问题，程序的内存分配同样存在线程安全的问题。**分配内存线程安全问题的两种解决方案**：

- 采用 CAS 加上失败自旋重试的方式保证更新操作的原子性（实际使用）。

- 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为**本地线程分配缓冲**（TLAB ，Thread Local Allocation Buffer），哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完，分配新的 TLAB 时才需要同步锁定。
  
### 2.2 对象的内存布局
HotSpot 虚拟机中，对象在内存中存储的布局可以分为三块区域：**对象头（Header）**、**实例数据（Instance Data）**和**对齐填充（Padding）**。

#### 2.2.1 对象头
HotSpot 虚拟机的对象头包括两部分信息：

- 用于存储对象自身的运行时数据，如：哈希码、GC 分代年龄、锁状态标志等，官方称为 ``“Mark Word”``；
- 类型指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

#### 2.2.2 实例数据
实例数据是对象真正存储的有效信息，也既是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录起来。

#### 2.2.3 对齐填充
对齐填充并不是必然存在的，也没有特别的含义，它仅仅**起着占位符的作用**。由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 **8 字节的整数倍**(换句话说，对象的大小必须是8字节的整数倍)。

### 2.3 对象的访问定位
Java 程序需要通过**栈上的对象引用（reference）数据（存储在栈上的局部变量表中）来操作堆上的具体对象**。由于 reference 类型在 Java 虚拟机规范里面也只规定了是一个指向对象的引用，并没有定义这个引用的具体实现，**对象访问方式也是取决于虚拟机的实现**。主流的访问方式有使用**句柄**和**直接指针**两种。

#### 2.3.1 句柄访问

使用句柄访问，Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。如下图：

<div align="center"> <img src="images/040102.png" width="520px"> </div><br>

#### 2.3.2 直接指针

使用访问，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址。如下图：

<div align="center"> <img src="images/040103.png" width="520px"> </div><br>

句柄访问的好处是 reference 中存储的是**稳定**的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。

直接指针访问的好处是**速度更快**，它节省了一次指针定位的时间开 销，由于对象访问的在 Java 中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。HotSpot VM 就是使用直接指针进行对象访问的。

# 参考
- [JDK7和JDK8的JVM内存模型的总结](https://blog.csdn.net/zhou920786312/article/details/97984663)
- [Java 8: 从永久代（PermGen）到元空间（Metaspace）](https://blog.csdn.net/zhyhang/article/details/17246223/)
- [Java方法区、永久代、元空间、常量池详解](https://blog.csdn.net/u011635492/article/details/81046174?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.pc_relevant_is_cache&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.pc_relevant_is_cache)
