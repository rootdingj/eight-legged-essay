Java 虚拟机--GC 算法与内存分配策略
====================
## 1 判断一个对象是否存活
垃圾收集器在对堆进行回收前，首先要确定对象中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。

### 1.1 引用计数算法
引用计数器判断对象是否存活的**基本思路**：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。

引用计数算法的实现简单，判定效率高，大部分情况下是一个不错的算法。但它没有被主流的 JVM 采用，主要原因是它**很难解决对象之间循环引用的问题**。

### 1.2 可达性分析算法
可达性分析算法判断对象是否存活的**基本思路**：通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是 GC Roots 到这个对象不可达）时，则证明此对象时不可用的。
<div align="center"> <img src="images/040201.png" width="520px"> </div><br>

_上图中，对象 object 5、object 6、object 7虽互有关联，但它们到 GC Roots是不可达的，所以它们将会被判定为是可回收的对象。_

在 Java 中，可作为 GC Roots 的对象包括以下几种：
- 虚拟机栈（栈帧中的局部变量表，Local Variable Table）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中 JNI（即一般说的Native方法）引用的对象。

### 1.3 引用类型
Java 将引用分为：强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)，这4种引用强度依次减弱。

- 强引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象；

  ```java
  // 使用 new 一个新对象的方式来创建强引用
  Object obj = new Object();
  ```

- 软引用，用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象列入回收范围之中进行对二次回收；

  ```java
  // 使用 SoftReference 类来创建软引用
  Object obj = new Object();
  SoftReference<Object> sf = new SoftReference<Object>(obj);
  // 使对象只被软引用关联
  obj = null; 
  ```

- 弱引用，用来描述非必须对象，被弱引用关联的对象只能生存到下一次垃圾回收之前；

  ```java
  // 使用 WeakReference 类来创建软引用
  Object obj = new Object();
  WeakReference<Object> wf = new WeakReference<Object>(obj);
  obj = null;
  ```

- 虚引用，虚引用是否存在不会对对象的生存时间构成影响，也不能通过虚引用来获取对象实例，它唯一的作用是能在对象被收集器回收时收到一个系统通知。

  ```java
  // 使用 PhantomReference 类来创建软引用
  Object obj = new Object();
  PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
  obj = null;
  ```
## 2 垃圾收集算法

### 2.1 标记－清除算法 
标记－清除（Mark-Sweep）算法，分为“标记”、“清除”两个阶段：
- **标记阶段**，程序会检查每个对象是否为活动对象，如果不是活动对象，则程序会在对象头部打上标记；
- **清除阶段**，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

标记－清除算法是最基础的垃圾收集算法，后续的收集算法都是基于它的思路并对其不足进行改进而得到的。它主要的不足有两点：
- 效率问题，标记和清除两个过程的效率都不高；
- 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。

### 2.2 复制算法
复制（Copying）算法 : 它将可用内存按容量**分成大小相等的两块**，每次只使用其中的一块，**当这一块内存用完，就将还存活着的对象复制到另一块上面**，然后再把已使用过的内存空间一次清理掉。

这样可以只对一块内存进行回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。虽然它解决标记-清除算法的效率问题，但使用内存缩小为原来的一半，代价有点高。

### 2.3 标记－整理算法 
标记－整理（Mark-Compact）算法 ：标记过程与“标记－清除算法”一样，但后续步骤不是直接对可回收对象进行清理，而是**让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存**。

复制算法在对象存活率较高时要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用复制算法，而用“标记－整理算法”。

### 2.4 分代收集算法 
分代收集（Generational Collection）算法 ：根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。当前商业虚拟机的垃圾收集都采用分代收集算法。

- **新生代**：在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活。选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

- **老年代**：在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，所以使用“标记－清除”或“标记－整理”算法来进行回收。

## 3 垃圾收集器
<div align="center"> <img src="images/040202.png" width="520px"> </div><br>
上图展示了 HotSpot 虚拟机中的 7 个垃圾收集器，若收集器之间存在连线则说明它们可以搭配使用。虚拟机所处区域，表示它是新生代收集器还是老年代收集器。

### 3.1 Serial 收集器
- **特性**

  Serial 收集器是一个单线程收集器。它只使用一个 CPU 或一条收集线程去完成收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有工作线程，直到收集结束。

- **运行示意图**

<div align="center"> <img src="images/040203.png" width="520px"> </div><br>

- **使用场景**

  Serial 收集器的优点是简单、高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的**单线程**收集效率。

  它是 **Client 模式**下的默认**新生代**收集器。它收集一两百兆垃圾的**停顿时间**可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。


### 3.2 ParNew 收集器
- **特性**

  ParNew 收集器是 Serial 收集器的**多线程**版本，除了使用多线程进行垃圾收集外，其余行为与 Serial 收集器完全一样。

- **运行示意图**

<div align="center"> <img src="images/040204.png" width="520px"> </div><br>

- **使用场景**

  它是许多运行在 **Server 模式**下的虚拟机中首选的**新生代**收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

### 3.3  Parallel Scavenge 收集器
- **特性**

   Parallel Scavenge 收集器和 ParNew 收集器一样是一个新生代收集器，也是使用复制算法、并行的多线程收集器。

   其它收集器目标是**尽可能缩短垃圾收集时用户线程的停顿时间**，而它的目标是达到一个**可控制的吞吐量**，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。

   吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)

- **使用场景**

  **停顿时间优先**，良好的响应速度能提升用户体验，适合需要与用户交互的程序。

  **吞吐量优先**，可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

### 3.4 Serial Old 收集器
- **特性**

  Serial Old 收集器是 Serial 收集器的**老年代**版本，是一个**单线程**收集器，使用**“标记－整理”算法**。

- **运行示意图**

<div align="center"> <img src="images/040205.png" width="520px"> </div><br>

- **使用场景**

  适用于 **Client 模式**下的虚拟机使用。如果用在 Server 场景下，它有两个用途：

  - 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
  - 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

### 3.5 Parallel Old 收集器
- **特性**

  Parallel Old 收集器是 Parallel Scavenge 收集器的**老年代**版本，使用**多线程**和**“标记－整理”算法**。

- **运行示意图**

<div align="center"> <img src="images/040206.png" width="520px"> </div><br>

- **使用场景**

  在注重吞吐量以及 CPU 资源敏感的场合，可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### 3.6 CMS 收集器
- **特性**

  CMS 收集器是一种以获取**最短回收停顿时间**为目标的收集器。它是基于**“标记－清除”算法**实现的，其运行过程分为4个步骤：

  - **初始标记**：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿；

  - **并发标记**：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿；

  - **重新标记**：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿；

  - **并发清除**：不需要停顿。

  具有以下缺点：

  - 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。

  - 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。**浮动垃圾**是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
  - 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

- **运行示意图**

<div align="center"> <img src="images/040207.png" width="520px"> </div><br>

- **使用场景**

  适用于重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验，常见于 Java 应用的互联网站服务端。

### 3.7 G1 收集器
- **特性**

  G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

  堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。其运行过程分为4个步骤：

  - 初始标记
  - 并发标记
  - 最终标记
  - 筛选回收

  具备如下特点：

  - 空间整合：整体来看是基于**“标记 - 整理”算法**实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
  - 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

- **运行示意图**

<div align="center"> <img src="images/040208.png" width="520px"> </div><br>

## 4 内存分配与回收策略
Java 的自动内存管理最终可以归结为自动化地解决了两个问题：
- 给对象分配内存
- 回收分配给对象的内存

内存分配与回收策略如下文。

### 4.1 对象优先在 Eden 分配
大多数情况下，对象在新生代的 Eden 区中分配。**当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。** 因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般比较快。

### 4.2 大对象直接进入老年代
大对象是指**需要连续内存空间的对象**，最典型的大对象是很长的字符串以及数组。经常出现大对象容易导致内存还有不少空间时就提前触发 GC 以获取足够的连续空间来安置它们。

虚拟机提供了一个 `-XX:PretenureSizeThreshold` 参数，令大于这个设置值的对象直接在老年代分配。避免在 Eden 和 Survivor 之间的大量内存复制。

### 4.3 长期存活的对象将进入老年代
虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为1。**对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中**。

对象晋升老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 设置。

### 4.4 动态对象年龄判定
为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了 `MaxTenuringThreshold` 才能晋升老年代，**如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代**，无须等到 `MaxTenuringThreshold` 中要求的年龄。

### 4.5 空间分配担保
在发生 Minor GC 之前，**虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC可以确保是安全的**。如果不成立，则虚拟机会查看 `HandlePromotionFailure` 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者`HandlePromotionFailure` 设置不允许**冒险**，那这时也要改为进行一次 Full GC。

### Minor GC 、Major GC 和 Full GC

- **Minor GC**：从新生代空间（包括Eden和Survivor）回收内存称为 Minor GC。因为 Java 对象大多都朝生夕灭，所以 Minor GC 非常频繁，一般回收速度也比较快。
- **Major GC**：清理老年代的 GC。
- **Full GC**：清理整个堆空间（包括新生代和老年代)，出现了 Full GC 经常会伴随至少一次 Minor GC。Full GC 的速度一般比 Minor GC 慢10倍以上。

#### Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有如下触发条件：

- **调用 System.gc()** ：此方法的调用是建议 JVM 进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而**增加 Full GC 的频率**，也即**增加了间歇性停顿的次数**。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过 ``-XX:+ DisableExplicitGC`` 来禁止 RMI 调用 System.gc()。

- **老年代空间不足** ：老年代空间不足的常见场景为前文所讲的**大对象直接进入老年代、长期存活的对象进入老年代等**。当执行 Full GC 后空间仍然不足，则抛出如下错误：``Java.lang.OutOfMemoryError: Java heap space`` 为避免以上两种状况引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。

- **空间分配担保失败** ：使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。

- JDK 1.7 及以前的永久代空间不足 ：在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放一些 Class 的信息、常量、静态变量等数据。  
当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。   
在 JDK 1.8 中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种 Full GC 触发的可能性。

- **Concurrent Mode Failure** ：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报Concurrent Mode Failure 错误，并触发 Full GC。


## 5 JVM 性能监控与故障处理工具

| 名称 | 中文名 |
| :--: | :--: |
| jps | JVM Process Status Tool，显示指定系统内所有的 JVM 进程         |
| jstat | JVM Statistics Monitoring Tool，收集 JVM 各方面的运行参数    |
| jinfo | Configuration info for java，显示 JVM 配置信息              |
| jmap | Memory Map for java，生成 JVM 的内存转储快照（heapdump 文件） |
| jhat | 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果 |
| jstack | Stack Trace for Java，Java 堆栈跟踪工具 |
| HSDIS | JIT 生成代码反汇编 |
| JConsole | Java 监视与管理控制台 |
| VisualVM | 多合一故障处理工具 |

### 常用的 Java 应用诊断

常用的 Java 应用诊断包括线程，变量，GC等方面的诊断。

- **jstack**

  `jstack` 命令通常配合 top 使用，`top -H -p pid` 定位 Java 进程和线程；再利用 `jstack -l pid` 转换线程栈。

- ### GC 诊断

  - **统计**

    jstat 命令可打印GC详细信息，年轻GC和完整GC次数，堆信息等。

    其命令格式为：`jstat –gcxxx -t pid` 

  - **映射**

    jmap 打印 Java 进程堆信息 `jmap –heap pid`。通过 `jmap –dump：file = xxx pid` 可转储堆到文件，然后通过其他工具进一步分析其堆使用情况。

  - MAT

    MAT 是 Java 堆的分析利器，提供了直观的诊断报告，内置的OQL允许对堆进行类SQL查询，功能强大，传出的引用和传入的引用可以对对象引用追根溯源。

# 参考

- [内存溢出与内存泄漏](https://www.cnblogs.com/xiaoxi/p/7354857.html)
- [Minor GC、Major GC 和 Full GC 之间的区别](https://zhuanlan.zhihu.com/p/86875263)
